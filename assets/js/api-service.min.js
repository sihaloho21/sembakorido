const ApiService={cache:new Map,pendingRequests:new Map,DEFAULT_CACHE_DURATION:3e5,MAX_RETRIES:3,INITIAL_RETRY_DELAY:1e3,clearCache(){this.cache.clear(),this.pendingRequests.clear(),console.log("üßπ [ApiService] Cache cleared successfully")},clearCacheForEndpoint(e){const t=`${CONFIG.getMainApiUrl()}${e}`,s=this._generateCacheKey(t,{});this.cache.delete(s),console.log("üßπ [ApiService] Cache cleared for endpoint:",e)},async fetch(e,t={}){const s=`${CONFIG.getMainApiUrl()}${e}`,c=this._generateCacheKey(s,t),i=!1!==t.cache;if(i&&this.cache.has(c)){const s=this.cache.get(c),i=t.cacheDuration||this.DEFAULT_CACHE_DURATION;if(Date.now()-s.timestamp<i)return console.log("üì¶ [ApiService] Using cached data:",e),s.data;console.log("‚è∞ [ApiService] Cache expired:",e),this.cache.delete(c)}if(this.pendingRequests.has(c))return console.log("‚è≥ [ApiService] Waiting for pending request:",e),this.pendingRequests.get(c);const a=this._fetchWithRetry(s,t);this.pendingRequests.set(c,a);try{const t=await a;return i&&(this.cache.set(c,{data:t,timestamp:Date.now()}),console.log("üíæ [ApiService] Data cached:",e)),t}catch(t){throw console.error("‚ùå [ApiService] Request failed:",e,t),t}finally{this.pendingRequests.delete(c)}},async _fetchWithRetry(e,t){const s=t.maxRetries||this.MAX_RETRIES;let c;for(let i=0;i<s;i++)try{console.log(`üåê [ApiService] Request attempt ${i+1}/${s}:`,e);const c=await fetch(e,{method:t.method||"GET",mode:"cors",headers:t.headers||{},body:t.body});if(429===c.status){if(i<s-1){const e=this._calculateBackoff(i);console.warn(`‚è±Ô∏è [ApiService] Rate limited (429), retrying in ${e}ms...`),await this._sleep(e);continue}throw new Error("Rate limit exceeded. Please try again later.")}if(!c.ok)throw new Error(`HTTP ${c.status}: ${c.statusText}`);const a=await c.json();return console.log("‚úÖ [ApiService] Request successful:",e),a}catch(e){if(c=e,i<s-1&&this._isRetryableError(e)){const t=this._calculateBackoff(i);console.warn(`üîÑ [ApiService] Retry ${i+1}/${s} after ${t}ms:`,e.message),await this._sleep(t);continue}break}throw c},_calculateBackoff(e){return this.INITIAL_RETRY_DELAY*Math.pow(2,e)},_isRetryableError:e=>e.message.includes("fetch")||e.message.includes("network")||e.message.includes("timeout"),_sleep:e=>new Promise(t=>setTimeout(t,e)),_generateCacheKey:(e,t)=>`${t.method||"GET"}:${e}:${t.body||""}`,clearCache(){const e=this.cache.size;return this.cache.clear(),console.log(`üóëÔ∏è [ApiService] Cache cleared: ${e} entries removed`),e},clearCacheForEndpoint(e){const t=`${CONFIG.getMainApiUrl()}${e}`;let s=0;for(const[e,c]of this.cache.entries())e.includes(t)&&(this.cache.delete(e),s++);return console.log(`üóëÔ∏è [ApiService] Cache cleared for ${e}: ${s} entries`),s},getCacheStats(){const e={totalEntries:this.cache.size,pendingRequests:this.pendingRequests.size,entries:[]};for(const[t,s]of this.cache.entries()){const c=Date.now()-s.timestamp;e.entries.push({key:t,age:Math.round(c/1e3),size:JSON.stringify(s.data).length})}return e},async post(e,t,s={}){return this.fetch(e,{...s,method:"POST",headers:{"Content-Type":"application/json",...s.headers},body:JSON.stringify(t),cache:!1})},async patch(e,t,s={}){return this.fetch(e,{...s,method:"PATCH",headers:{"Content-Type":"application/json",...s.headers},body:JSON.stringify(t),cache:!1})},async get(e,t={}){return this.fetch(e,{...t,method:"GET"})}};window.ApiService=ApiService;